package com.example.AI_Diary.controller;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.example.AI_Diary.model.Diary;
import com.example.AI_Diary.model.User;
import com.example.AI_Diary.service.DiaryService;
import com.example.AI_Diary.service.SentimentAnalysisService;
import com.example.AI_Diary.service.UserService;
import com.example.AI_Diary.util.JwtTokenUtil;

@RestController
@RequestMapping("/api/diaries")
@CrossOrigin(origins = "http://localhost:3000")
public class DiaryController {

    @Autowired
    private DiaryService diaryService;

    @Autowired
    private SentimentAnalysisService sentimentAnalysisService;

    @Autowired
    private UserService userService;

    @Autowired
    private JwtTokenUtil jwtTokenUtil;

    @PostMapping
    public ResponseEntity<Diary> createDiary(
            @RequestParam("title") String title,
            @RequestParam("content") String content,
            @RequestParam(value = "image", required = false) MultipartFile image,
            @RequestParam(value = "tags", required = false) List<String> tags,
            @RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Diary diary = new Diary();
        diary.setTitle(title);
        diary.setContent(content);
        diary.setUserId(user.getId());
        diary.setCreatedAt(LocalDateTime.now());
        diary.setTags(tags); // 태그 설정

        if (image != null && !image.isEmpty()) {
            try {
                diary.setImage(image.getBytes());
            } catch (Exception e) {
                throw new RuntimeException("이미지 저장 실패", e);
            }
        }

        // 감정 분석 및 저장
        String emotion = sentimentAnalysisService.analyzeSentiment(diary.getContent());
        diary.setEmotion(emotion);

        return ResponseEntity.ok(diaryService.saveDiary(diary));
    }

    @GetMapping
    public ResponseEntity<List<Diary>> getDiaries(@RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));
        List<Diary> diaries = diaryService.findByUserId(user.getId());

        // 이미지 Base64 인코딩
        List<Diary> encodedDiaries = diaries.stream().map(diary -> {
            if (diary.getImage() != null) {
                diary.setImageBase64(Base64.getEncoder().encodeToString(diary.getImage()));
            }
            return diary;
        }).collect(Collectors.toList());
        return ResponseEntity.ok(encodedDiaries);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Diary> getDiaryById(@PathVariable Long id) {
        return diaryService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/date")
    public ResponseEntity<List<Diary>> getDiariesByDate(
            @RequestParam("date") String date,
            @RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        LocalDateTime startOfDay = LocalDateTime.parse(date + "T00:00:00");
        LocalDateTime endOfDay = startOfDay;

        List<Diary> diaries = diaryService.findByUserIdAndCreatedAtBetween(user.getId(), startOfDay, endOfDay);

        // 이미지 Base64 인코딩
        List<Diary> encodedDiaries = diaries.stream().map(diary -> {
            if (diary.getImage() != null) {
                diary.setImageBase64(Base64.getEncoder().encodeToString(diary.getImage()));
            }
            return diary;
        }).collect(Collectors.toList());
        return ResponseEntity.ok(encodedDiaries);
    }


    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteDiary(@PathVariable Long id, @RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Diary diary = diaryService.findById(id)
                .orElseThrow(() -> new RuntimeException("Diary not found"));

        if (!diary.getUserId().equals(user.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); // 삭제 권한이 없는 경우
        }

        diaryService.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{id}")
    public ResponseEntity<Diary> updateDiary(
            @PathVariable Long id,
            @RequestParam("title") String title,
            @RequestParam("content") String content,
            @RequestParam(value = "image", required = false) MultipartFile image,
            @RequestParam(value = "tags", required = false) List<String> tags,
            @RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Diary diary = diaryService.findById(id)
                .orElseThrow(() -> new RuntimeException("Diary not found"));

        if (!diary.getUserId().equals(user.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); // 수정 권한이 없는 경우
        }

        diary.setTitle(title);
        diary.setContent(content);
        diary.setTags(tags); // 태그 설정

        if (image != null && !image.isEmpty()) {
            try {
                diary.setImage(image.getBytes());
            } catch (Exception e) {
                throw new RuntimeException("이미지 저장 실패", e);
            }
        }

        // 감정 분석 및 저장
        String emotion = sentimentAnalysisService.analyzeSentiment(diary.getContent());
        diary.setEmotion(emotion);

        return ResponseEntity.ok(diaryService.saveDiary(diary));
    }

    @GetMapping("/search")
    public ResponseEntity<List<Diary>> searchDiariesByTag(@RequestParam String tag, @RequestHeader("Authorization") String token) {
        String jwtToken = token.substring(7); // Bearer 토큰 제거
        String usernameOrEmail = jwtTokenUtil.getUsernameFromToken(jwtToken);
        User user = userService.findByUsernameOrEmail(usernameOrEmail)
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<Diary> diaries = diaryService.findByUserIdAndTag(user.getId(), tag);

        // 이미지 Base64 인코딩
        List<Diary> encodedDiaries = diaries.stream().map(diary -> {
            if (diary.getImage() != null) {
                diary.setImageBase64(Base64.getEncoder().encodeToString(diary.getImage()));
            }
            return diary;
        }).collect(Collectors.toList());
        return ResponseEntity.ok(encodedDiaries);
    }
}
